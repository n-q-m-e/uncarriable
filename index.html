<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Uncarriable</title>
<meta name="description" content="An art collective. Undefined, uncontainable.">
<meta property="og:title" content="Uncarriable">
<meta property="og:description" content="An art collective. Undefined, uncontainable.">
<meta property="og:url" content="https://uncarriable.com">
<meta property="og:type" content="website">
<meta property="og:image" content="https://uncarriable.com/og.png">
<meta name="theme-color" content="#0040ff">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Uncarriable">
<meta name="twitter:description" content="An art collective. Undefined, uncontainable.">
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAALUlEQVR4nO3OIQEAAAwCMKK9fykeAzMxv+TaKQEBAQEBAQEBAQEBAQEBgXXgAVSU+HnCashAAAAAAElFTkSuQmCC">
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#000}
canvas{display:block}
#grain{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;opacity:0.25;mix-blend-mode:overlay;z-index:10}
#scanlines{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:11;background:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,0,0,0.06) 2px,rgba(0,0,0,0.06) 4px);animation:scanmove 8s linear infinite}
@keyframes scanmove{0%{background-position:0 0}100%{background-position:0 100px}}
</style>
</head>
<body>

<canvas id="grain"></canvas>
<div id="scanlines"></div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

// --- Detect mobile ---
const isMobile = /Android|iPhone|iPad|iPod|webOS/i.test(navigator.userAgent) || window.innerWidth < 768;

// --- Config ---
const COLORS = [
  new THREE.Color('#0040ff'),
  new THREE.Color('#ff4400'),
  new THREE.Color('#8800ff'),
  new THREE.Color('#cc0033')
];
const CYCLE_DURATION = 270;
const BLOOM_STRENGTH = isMobile ? 1.3 : 1.2;
const BLOOM_RADIUS = isMobile ? 0.65 : 0.7;
const BLOOM_THRESHOLD = isMobile ? 0.08 : 0.1;
const GRID_SIZE = isMobile ? 24 : 40;
const GRID_SPACING = isMobile ? 0.11 : 0.08;
const TUBE_RADIUS = 0.02;

// --- Scene setup ---
const renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: 'high-performance' });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
renderer.toneMapping = THREE.ReinhardToneMapping;
renderer.toneMappingExposure = isMobile ? 1.0 : 1.1;
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.prepend(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color('#050505');
scene.fog = new THREE.FogExp2('#050505', 0.018);

const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(0, 3.5, 6);

// --- Post-processing: Bloom + Chromatic Aberration + Vignette ---
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
composer.addPass(new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  BLOOM_STRENGTH, BLOOM_RADIUS, BLOOM_THRESHOLD
));

// Combined chromatic aberration + vignette shader
const FXShader = {
  uniforms: {
    tDiffuse: { value: null },
    chromaAmount: { value: isMobile ? 0.002 : 0.003 },
    vignetteStart: { value: 0.4 },
    vignetteEnd: { value: 1.2 }
  },
  vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform float chromaAmount;
    uniform float vignetteStart;
    uniform float vignetteEnd;
    varying vec2 vUv;
    void main(){
      vec2 dir = vUv - vec2(0.5);
      vec2 offset = dir * chromaAmount;
      float r = texture2D(tDiffuse, vUv + offset).r;
      float g = texture2D(tDiffuse, vUv).g;
      float b = texture2D(tDiffuse, vUv - offset).b;
      vec3 col = vec3(r, g, b);
      float dist = length(dir) * 2.0;
      float vig = 1.0 - smoothstep(vignetteStart, vignetteEnd, dist);
      col *= vig;
      gl_FragColor = vec4(col, 1.0);
    }`
};
composer.addPass(new ShaderPass(FXShader));

// --- Height function ---
function tubeHeight(nx, nz) {
  const r = Math.sqrt(nx * nx + nz * nz);
  const angle = Math.atan2(nz, nx);
  const dome = Math.max(0, 1.0 - r * 0.9);
  const wave1 = Math.sin(nx * 5.3 + nz * 3.7) * 0.35;
  const wave2 = Math.cos(nz * 7.1 - nx * 2.3) * 0.25;
  const wave3 = Math.sin(r * 9.0 + angle * 3.0) * 0.2;
  const wave4 = Math.cos(angle * 5.0 + r * 6.0) * Math.sin(r * 4.0) * 0.3;
  const ridge1 = Math.abs(Math.sin(nx * 11.0 + nz * 7.0)) * 0.15;
  const ridge2 = Math.abs(Math.cos(angle * 7.0 + r * 5.0)) * 0.2;
  const spire = Math.exp(-r * r * 8.0) * 1.2;
  const asym = Math.sin(nx * 3.0) * Math.cos(nz * 5.0) * 0.2;
  const ring1 = Math.exp(-Math.pow(r - 0.4, 2) * 60.0) * 0.5;
  const ring2 = Math.exp(-Math.pow(r - 0.7, 2) * 40.0) * 0.3;
  const h = dome * (1.0 + wave1 + wave2 + wave3 + wave4 + ridge1 + ridge2 + asym) + spire + ring1 + ring2;
  return Math.max(0.05, h * 1.4);
}

// --- Build main structure ---
function buildStructure(group, mat, gridSize, spacing, scale) {
  const geo = new THREE.BoxGeometry(TUBE_RADIUS * 1.6 * scale, 1, TUBE_RADIUS * 1.6 * scale);
  const total = gridSize * gridSize;
  const inst = new THREE.InstancedMesh(geo, mat, total);
  inst.frustumCulled = false;
  const cAttr = new Float32Array(total * 3);
  const d = new THREE.Object3D();
  const half = (gridSize - 1) * spacing * 0.5;
  let i = 0, mH = 0;
  const hs = [];
  for (let ix = 0; ix < gridSize; ix++) {
    for (let iz = 0; iz < gridSize; iz++) {
      const x = ix * spacing - half;
      const z = iz * spacing - half;
      const nx = (ix / (gridSize - 1)) * 2 - 1;
      const nz = (iz / (gridSize - 1)) * 2 - 1;
      const h = tubeHeight(nx, nz) * scale;
      hs.push(h);
      if (h > mH) mH = h;
      d.position.set(x * scale, h * 0.5, z * scale);
      d.scale.set(1, h, 1);
      d.updateMatrix();
      inst.setMatrixAt(i++, d.matrix);
    }
  }
  for (let j = 0; j < total; j++) {
    const t = hs[j] / mH;
    const b = 0.3 + t * 0.7;
    cAttr[j * 3] = b; cAttr[j * 3 + 1] = b; cAttr[j * 3 + 2] = b;
  }
  inst.instanceColor = new THREE.InstancedBufferAttribute(cAttr, 3);
  inst.instanceMatrix.needsUpdate = true;
  group.add(inst);
  return inst;
}

// Main structure
const tubeGroup = new THREE.Group();
scene.add(tubeGroup);
const material = new THREE.MeshStandardMaterial({
  color: '#000000', emissive: COLORS[0].clone(),
  emissiveIntensity: 0.8, roughness: 0.3, metalness: 0.7
});
buildStructure(tubeGroup, material, GRID_SIZE, GRID_SPACING, 1.0);
tubeGroup.position.set(0, -0.4, 0);

// Ghost structure (smaller echo)
const ghostGroup = new THREE.Group();
scene.add(ghostGroup);
const ghostMat = new THREE.MeshStandardMaterial({
  color: '#000000', emissive: COLORS[0].clone(),
  emissiveIntensity: 0.3, roughness: 0.5, metalness: 0.5,
  transparent: true, opacity: 0.35
});
const ghostSize = isMobile ? 16 : 25;
buildStructure(ghostGroup, ghostMat, ghostSize, GRID_SPACING, 0.5);
ghostGroup.position.set(1.8, -0.6, -1.2);
ghostGroup.rotation.y = Math.PI * 0.3;

// --- Reflective floor ---
const floorGeo = new THREE.PlaneGeometry(20, 20);
const floorMat = new THREE.MeshStandardMaterial({
  color: '#030308', roughness: 0.2, metalness: 0.95,
  transparent: true, opacity: 0.6
});
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI / 2;
floor.position.y = -0.4;
scene.add(floor);

// --- Particles ---
const PARTICLE_COUNT = isMobile ? 60 : 150;
const particleGeo = new THREE.BufferGeometry();
const particlePositions = new Float32Array(PARTICLE_COUNT * 3);
const particleSpeeds = new Float32Array(PARTICLE_COUNT);
for (let i = 0; i < PARTICLE_COUNT; i++) {
  particlePositions[i * 3] = (Math.random() - 0.5) * 8;
  particlePositions[i * 3 + 1] = Math.random() * 5 - 0.5;
  particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 8;
  particleSpeeds[i] = 0.002 + Math.random() * 0.005;
}
particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
const particleMat = new THREE.PointsMaterial({
  color: '#ffffff', size: isMobile ? 0.025 : 0.018,
  transparent: true, opacity: 0.25,
  blending: THREE.AdditiveBlending, depthWrite: false
});
const particles = new THREE.Points(particleGeo, particleMat);
scene.add(particles);

const ambient = new THREE.AmbientLight('#111111', 0.1);
scene.add(ambient);

// --- Grain ---
const grainCanvas = document.getElementById('grain');
const grainCtx = grainCanvas.getContext('2d');
function resizeGrain() {
  grainCanvas.width = Math.floor(window.innerWidth * 0.5);
  grainCanvas.height = Math.floor(window.innerHeight * 0.5);
}
resizeGrain();
function renderGrain() {
  const w = grainCanvas.width, h = grainCanvas.height;
  const img = grainCtx.createImageData(w, h);
  const d = img.data;
  for (let i = 0; i < d.length; i += 4) {
    const v = Math.random() * 255;
    d[i] = v; d[i+1] = v; d[i+2] = v; d[i+3] = 40;
  }
  grainCtx.putImageData(img, 0, 0);
}
renderGrain();
setInterval(renderGrain, 100);

// --- Color cycling ---
function lerpColor(a, b, t) {
  return new THREE.Color(a.r+(b.r-a.r)*t, a.g+(b.g-a.g)*t, a.b+(b.b-a.b)*t);
}
function getCurrentEmissive(time) {
  const seg = CYCLE_DURATION / COLORS.length;
  const ct = time % CYCLE_DURATION;
  const si = Math.floor(ct / seg);
  const sp = (ct % seg) / seg;
  const t = sp * sp * (3 - 2 * sp);
  return lerpColor(COLORS[si % COLORS.length], COLORS[(si+1) % COLORS.length], t);
}

// --- Animation ---
const clock = new THREE.Clock();
const orbitRadius = isMobile ? 7.5 : 6.5;
const orbitSpeed = 0.015;
const vertOscAmp = 0.4;
const vertOscFreq = 0.08;

function animate() {
  requestAnimationFrame(animate);
  const elapsed = clock.getElapsedTime();

  // Camera orbit
  const angle = elapsed * orbitSpeed;
  camera.position.x = Math.sin(angle) * orbitRadius;
  camera.position.z = Math.cos(angle) * orbitRadius;
  camera.position.y = 2.2 + Math.sin(elapsed * vertOscFreq) * vertOscAmp;
  camera.lookAt(0, 0.8, 0);

  // Structure rotations
  tubeGroup.rotation.y = elapsed * 0.008;
  ghostGroup.rotation.y = Math.PI * 0.3 - elapsed * 0.005;

  // Emissive pulse (slow breathing via intensity)
  const pulse = 0.7 + Math.sin(elapsed * 0.4) * 0.15;
  material.emissiveIntensity = pulse;
  ghostMat.emissiveIntensity = pulse * 0.4;

  // Particles
  const pos = particles.geometry.attributes.position.array;
  for (let i = 0; i < PARTICLE_COUNT; i++) {
    pos[i*3+1] += particleSpeeds[i];
    if (pos[i*3+1] > 5) {
      pos[i*3] = (Math.random()-0.5)*8;
      pos[i*3+1] = -0.5;
      pos[i*3+2] = (Math.random()-0.5)*8;
    }
    pos[i*3] += Math.sin(elapsed*0.5+i)*0.0003;
    pos[i*3+2] += Math.cos(elapsed*0.3+i)*0.0003;
  }
  particles.geometry.attributes.position.needsUpdate = true;

  // Color cycling
  const emissive = getCurrentEmissive(elapsed);
  material.emissive.copy(emissive);
  ghostMat.emissive.copy(emissive);
  particleMat.color.copy(emissive);
  floorMat.color.copy(emissive).multiplyScalar(0.03);

  composer.render();
}
animate();

// --- Resize ---
function onResize() {
  const w = window.innerWidth, h = window.innerHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
  composer.setSize(w, h);
  resizeGrain();
}
window.addEventListener('resize', onResize);
</script>
</body>
</html>
