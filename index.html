<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Uncarriable</title>
<meta name="description" content="An art collective. Undefined, uncontainable.">
<meta property="og:title" content="Uncarriable">
<meta property="og:description" content="An art collective. Undefined, uncontainable.">
<meta property="og:url" content="https://uncarriable.com">
<meta property="og:type" content="website">
<meta property="og:image" content="https://uncarriable.com/og.png">
<meta name="theme-color" content="#0040ff">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Uncarriable">
<meta name="twitter:description" content="An art collective. Undefined, uncontainable.">
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAALUlEQVR4nO3OIQEAAAwCMKK9fykeAzMxv+TaKQEBAQEBAQEBAQEBAQEBgXXgAVSU+HnCashAAAAAAElFTkSuQmCC">
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#000}
canvas{display:block}
</style>
</head>
<body>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

// --- Detect mobile ---
const isMobile = /Android|iPhone|iPad|iPod|webOS/i.test(navigator.userAgent) || window.innerWidth < 768;

// --- Config ---
const COLORS = [
  new THREE.Color('#0040ff'),
  new THREE.Color('#ff4400'),
  new THREE.Color('#8800ff'),
  new THREE.Color('#cc0033')
];
const CYCLE_DURATION = 270;
const BLOOM_STRENGTH = isMobile ? 0.8 : 0.7;
const BLOOM_RADIUS = 0.5;
const BLOOM_THRESHOLD = isMobile ? 0.15 : 0.2;
const GRID_SIZE = isMobile ? 8 : 12;
const GRID_SPACING = isMobile ? 0.45 : 0.35;
const TUBE_RADIUS = 0.035;

// --- Scene setup ---
const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1));
renderer.toneMapping = THREE.ReinhardToneMapping;
renderer.toneMappingExposure = isMobile ? 1.0 : 1.1;
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.prepend(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color('#0a0a12');
scene.fog = new THREE.FogExp2('#0a0a12', 0.018);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 100);
camera.position.set(0, 2.5, 4);

// --- Morphing (GPU vertex displacement) ---
const morphTime = { value: 0 };
function addMorphing(mat) {
  mat.onBeforeCompile = (shader) => {
    shader.uniforms.uMorphTime = morphTime;
    shader.vertexShader = shader.vertexShader.replace(
      '#include <common>',
      '#include <common>\nuniform float uMorphTime;'
    );
    shader.vertexShader = shader.vertexShader.replace(
      '#include <project_vertex>',
      `vec4 mvPosition = vec4(transformed, 1.0);
       #ifdef USE_BATCHING
         mvPosition = batchingMatrix * mvPosition;
       #endif
       #ifdef USE_INSTANCING
         mvPosition = instanceMatrix * mvPosition;
       #endif
       float morphW = sin(mvPosition.x * 3.0 + uMorphTime * 0.3) * 0.12
                    + cos(mvPosition.z * 2.5 + uMorphTime * 0.25) * 0.08
                    + sin((mvPosition.x - mvPosition.z) * 1.5 + uMorphTime * 0.15) * 0.06;
       mvPosition.y *= (1.0 + morphW);
       mvPosition = modelViewMatrix * mvPosition;
       gl_Position = projectionMatrix * mvPosition;`
    );
  };
}

// --- Materials ---
const material = new THREE.MeshBasicMaterial({
  color: COLORS[0].clone()
});
addMorphing(material);


// --- Height function ---
function tubeHeight(nx, nz) {
  const r = Math.sqrt(nx * nx + nz * nz);
  const angle = Math.atan2(nz, nx);
  const dome = Math.max(0, 1.0 - r * 0.9);
  const wave1 = Math.sin(nx * 5.3 + nz * 3.7) * 0.35;
  const wave2 = Math.cos(nz * 7.1 - nx * 2.3) * 0.25;
  const wave3 = Math.sin(r * 9.0 + angle * 3.0) * 0.2;
  const wave4 = Math.cos(angle * 5.0 + r * 6.0) * Math.sin(r * 4.0) * 0.3;
  const ridge1 = Math.abs(Math.sin(nx * 11.0 + nz * 7.0)) * 0.15;
  const ridge2 = Math.abs(Math.cos(angle * 7.0 + r * 5.0)) * 0.2;
  const spire = Math.exp(-r * r * 8.0) * 1.2;
  const asym = Math.sin(nx * 3.0) * Math.cos(nz * 5.0) * 0.2;
  const ring1 = Math.exp(-Math.pow(r - 0.4, 2) * 60.0) * 0.5;
  const ring2 = Math.exp(-Math.pow(r - 0.7, 2) * 40.0) * 0.3;
  const h = dome * (1.0 + wave1 + wave2 + wave3 + wave4 + ridge1 + ridge2 + asym) + spire + ring1 + ring2;
  return Math.max(0.05, h * 1.4);
}

// --- Build structure ---
function buildStructure(group, mat, gridSize, spacing, scale) {
  const geo = new THREE.BoxGeometry(TUBE_RADIUS * 1.6 * scale, 1, TUBE_RADIUS * 1.6 * scale);
  const total = gridSize * gridSize;
  const inst = new THREE.InstancedMesh(geo, mat, total);
  inst.frustumCulled = false;
  const cAttr = new Float32Array(total * 3);
  const d = new THREE.Object3D();
  const half = (gridSize - 1) * spacing * 0.5;
  let i = 0, mH = 0;
  const hs = [];
  for (let ix = 0; ix < gridSize; ix++) {
    for (let iz = 0; iz < gridSize; iz++) {
      const x = ix * spacing - half;
      const z = iz * spacing - half;
      const nx = (ix / (gridSize - 1)) * 2 - 1;
      const nz = (iz / (gridSize - 1)) * 2 - 1;
      const h = tubeHeight(nx, nz) * scale;
      hs.push(h);
      if (h > mH) mH = h;
      d.position.set(x * scale, h * 0.5, z * scale);
      d.scale.set(1, h, 1);
      d.updateMatrix();
      inst.setMatrixAt(i++, d.matrix);
    }
  }
  const tmpCol = new THREE.Color();
  for (let j = 0; j < total; j++) {
    const ix = Math.floor(j / gridSize);
    const iz = j % gridSize;
    const px = ix / (gridSize - 1);
    const pz = iz / (gridSize - 1);
    const t = hs[j] / mH;
    // Rainbow gradient based on position, brighter at top
    const hue = (px * 0.6 + pz * 0.4 + t * 0.15) % 1.0;
    tmpCol.setHSL(hue, 0.75, 0.35 + t * 0.35);
    cAttr[j * 3]     = tmpCol.r;
    cAttr[j * 3 + 1] = tmpCol.g;
    cAttr[j * 3 + 2] = tmpCol.b;
  }
  inst.instanceColor = new THREE.InstancedBufferAttribute(cAttr, 3);
  inst.instanceMatrix.needsUpdate = true;
  group.add(inst);
  return inst;
}

// --- Main structure ---
const tubeGroup = new THREE.Group();
scene.add(tubeGroup);
buildStructure(tubeGroup, material, GRID_SIZE, GRID_SPACING, 1.0);
tubeGroup.position.set(0, -0.4, 0);

// --- Reflection (mirrored structure below floor) ---
const reflMat = new THREE.MeshBasicMaterial({
  color: COLORS[0].clone(), transparent: true, opacity: 0.2
});
addMorphing(reflMat);
const reflGroup = new THREE.Group();
scene.add(reflGroup);
const reflGrid = isMobile ? 6 : 8;
buildStructure(reflGroup, reflMat, reflGrid, GRID_SPACING, 1.0);
reflGroup.position.set(0, -0.4, 0);
reflGroup.scale.y = -1;

// --- Floor ---
const floorMat = new THREE.MeshBasicMaterial({
  color: '#060612', transparent: true, opacity: 0.45
});
const floor = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), floorMat);
floor.rotation.x = -Math.PI / 2;
floor.position.y = -0.4;
scene.add(floor);

// --- Particles ---
const PARTICLE_COUNT = isMobile ? 20 : 50;
const particleGeo = new THREE.BufferGeometry();
const particlePositions = new Float32Array(PARTICLE_COUNT * 3);
const particleSpeeds = new Float32Array(PARTICLE_COUNT);
for (let i = 0; i < PARTICLE_COUNT; i++) {
  particlePositions[i * 3] = (Math.random() - 0.5) * 8;
  particlePositions[i * 3 + 1] = Math.random() * 5 - 0.5;
  particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 8;
  particleSpeeds[i] = 0.002 + Math.random() * 0.005;
}
particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
const particleMat = new THREE.PointsMaterial({
  color: '#ffffff', size: isMobile ? 0.012 : 0.008,
  transparent: true, opacity: 0.25,
  blending: THREE.AdditiveBlending, depthWrite: false
});
const particles = new THREE.Points(particleGeo, particleMat);
scene.add(particles);


// --- Post-processing ---
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
composer.addPass(new UnrealBloomPass(
  new THREE.Vector2(Math.floor(window.innerWidth / 2), Math.floor(window.innerHeight / 2)),
  BLOOM_STRENGTH, BLOOM_RADIUS, BLOOM_THRESHOLD
));

// All FX in one shader: chromatic aberration + film burn + grain + scanlines + vignette
const FXShader = {
  uniforms: {
    tDiffuse: { value: null },
    uTime: { value: 0 },
    chromaAmount: { value: isMobile ? 0.002 : 0.003 },
    vignetteStart: { value: 0.4 },
    vignetteEnd: { value: 1.2 },
    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
  },
  vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform float uTime;
    uniform float chromaAmount;
    uniform float vignetteStart;
    uniform float vignetteEnd;
    uniform vec2 resolution;
    varying vec2 vUv;

    // Fast GPU noise (hash-based)
    float hash(vec2 p) {
      vec3 p3 = fract(vec3(p.xyx) * 0.1031);
      p3 += dot(p3, p3.yzx + 33.33);
      return fract((p3.x + p3.y) * p3.z);
    }

    void main(){
      vec2 uv = vUv;

      // --- Tilt-shift depth of field ---
      float dofDist = abs(vUv.y - 0.42);
      float dofBlur = smoothstep(0.05, 0.45, dofDist) * ${isMobile ? '0.003' : '0.004'};
      vec3 col = vec3(0.0);
      col += texture2D(tDiffuse, uv).rgb * 0.36;
      col += texture2D(tDiffuse, uv + vec2(dofBlur, 0.0)).rgb * 0.16;
      col += texture2D(tDiffuse, uv - vec2(dofBlur, 0.0)).rgb * 0.16;
      col += texture2D(tDiffuse, uv + vec2(0.0, dofBlur)).rgb * 0.16;
      col += texture2D(tDiffuse, uv - vec2(0.0, dofBlur)).rgb * 0.16;

      // Chromatic aberration
      vec2 cd = uv - vec2(0.5);
      vec2 co = cd * chromaAmount;
      col.r = mix(col.r, texture2D(tDiffuse, uv + co).r, 0.5);
      col.b = mix(col.b, texture2D(tDiffuse, uv - co).b, 0.5);

      // Film burn / light leaks
      vec2 lp1 = uv - vec2(0.1 + sin(uTime * 0.07) * 0.15, 0.2 + cos(uTime * 0.09) * 0.2);
      vec2 lp2 = uv - vec2(0.85 + cos(uTime * 0.05) * 0.1, 0.7 + sin(uTime * 0.08) * 0.15);
      col += vec3(1.0, 0.6, 0.2) * exp(-dot(lp1, lp1) * 8.0) * 0.08;
      col += vec3(0.8, 0.3, 0.6) * exp(-dot(lp2, lp2) * 10.0) * 0.06;
      ${!isMobile ? `
      vec2 lp3 = uv - vec2(0.5 + sin(uTime * 0.06) * 0.3, 0.9 + cos(uTime * 0.04) * 0.05);
      col += vec3(0.4, 0.6, 1.0) * exp(-dot(lp3, lp3) * 12.0) * 0.05;
      ` : ''}

      // Grain
      vec2 grainCoord = gl_FragCoord.xy + vec2(uTime * 100.0, uTime * 77.0);
      float grain = hash(grainCoord) * 0.06 - 0.03;
      col += grain;

      // Scanlines
      float scanline = sin(gl_FragCoord.y * 1.5) * 0.012;
      col -= scanline;

      // Letterbox (cinematic bars)
      float barSize = 0.07;
      float barFade = smoothstep(0.0, barSize, vUv.y) * smoothstep(0.0, barSize, 1.0 - vUv.y);
      col *= barFade;

      gl_FragColor = vec4(col, 1.0);
    }`
};
const fxPass = new ShaderPass(FXShader);
composer.addPass(fxPass);

// --- Color cycling ---
function lerpColor(a, b, t) {
  return new THREE.Color(a.r + (b.r - a.r) * t, a.g + (b.g - a.g) * t, a.b + (b.b - a.b) * t);
}
function getCurrentEmissive(time) {
  const seg = CYCLE_DURATION / COLORS.length;
  const ct = time % CYCLE_DURATION;
  const si = Math.floor(ct / seg);
  const sp = (ct % seg) / seg;
  const t = sp * sp * (3 - 2 * sp);
  return lerpColor(COLORS[si % COLORS.length], COLORS[(si + 1) % COLORS.length], t);
}

// --- Animation ---
const clock = new THREE.Clock();
const orbitRadius = isMobile ? 1.0 : 1.2;
const white = new THREE.Color(1, 1, 1);

function animate() {
  requestAnimationFrame(animate);
  const elapsed = clock.getElapsedTime();

  morphTime.value = elapsed;
  fxPass.uniforms.uTime.value = elapsed;

  // Cinematic camera — slow orbit + multi-frequency sway
  const angle = elapsed * 0.006;
  const sway1 = Math.sin(elapsed * 0.017) * 0.15;
  const sway2 = Math.cos(elapsed * 0.011) * 0.08;
  camera.position.x = Math.sin(angle) * orbitRadius + sway1;
  camera.position.z = Math.cos(angle) * orbitRadius + sway2;
  camera.position.y = 0.35 + Math.sin(elapsed * 0.025) * 0.12 + Math.cos(elapsed * 0.013) * 0.06;
  camera.lookAt(sway2 * 0.3, 0.7, sway1 * 0.3);

  // Structure rotation
  tubeGroup.rotation.y = elapsed * 0.005;
  reflGroup.rotation.y = elapsed * 0.005;

  // Pulse
  const pulse = 0.7 + Math.sin(elapsed * 0.3) * 0.15;

  // Particles
  const pos = particles.geometry.attributes.position.array;
  for (let i = 0; i < PARTICLE_COUNT; i++) {
    pos[i * 3 + 1] += particleSpeeds[i];
    if (pos[i * 3 + 1] > 5) {
      pos[i * 3] = (Math.random() - 0.5) * 8;
      pos[i * 3 + 1] = -0.5;
      pos[i * 3 + 2] = (Math.random() - 0.5) * 8;
    }
    pos[i * 3] += Math.sin(elapsed * 0.5 + i) * 0.0003;
    pos[i * 3 + 2] += Math.cos(elapsed * 0.3 + i) * 0.0003;
  }
  particles.geometry.attributes.position.needsUpdate = true;

  // Color cycling — subtle tint so rainbow instance colors show through
  const emissive = getCurrentEmissive(elapsed);
  material.color.set(1, 1, 1).lerp(emissive, 0.25).multiplyScalar(pulse);
  reflMat.color.set(1, 1, 1).lerp(emissive, 0.15).multiplyScalar(pulse * 0.4);
  particleMat.color.copy(emissive);
  floorMat.color.copy(emissive).multiplyScalar(0.05);

  composer.render();
}
animate();

// --- Resize ---
function onResize() {
  const w = window.innerWidth, h = window.innerHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
  composer.setSize(w, h);
  fxPass.uniforms.resolution.value.set(w, h);
}
window.addEventListener('resize', onResize);
</script>
</body>
</html>
